using System.Collections.Generic;
using Newtonsoft.Json.Linq;
using System.Text.Json;

namespace Battle.Simulator
{
    public class SimulatorTableEntryItemSkill : SimulatorTableEntry
    {
        #region BASE

        public SimulatorTableEntryItemSkill()
        {
            SetValue(eDataFloat.ENABLE, 1.0f);
            SetValue(eDataFloat.ENABLE_NEXT, 1.0f);
        }

        public void ToObject(string id, JToken token)
        {
            if (null == token)
            {
                return;
            }
            // enum들 기준으로.
            var children = token.Children();
            foreach (var child in children)
            {
                if (!(child is JProperty jp))
                {
                    continue;
                }
                //UnityEngine.Debug.Log("!!! 1 : " + name.Key + " : " + name.Value);
                if (SimulatorUtility.TryParse(jp.Name, out eDataInt enumI))
                {
                    if (SimulatorUtility.TryParse(jp.Value.ToString(), out int value))
                    {
                        SetValue(enumI, value);
                    }
                    //UnityEngine.Debug.Log("!!! 2 " + enumI  + ", " + name.Key + " : " + name.Value);
                    continue;
                }
                if (SimulatorUtility.TryParse(jp.Name, out eDataFloat enumF))
                {
                    if (SimulatorUtility.TryParse(jp.Value.ToString(), out double value))
                    {
                        var floatValue = (float)(System.Math.Truncate(value * 1000) * 0.001);
                        SetValue(enumF, floatValue);
                    }
                    //UnityEngine.Debug.Log("!!! 3 " + enumF + " : " + value + ", " + floatValue);
                    continue;
                }
                if (SimulatorUtility.TryParse(jp.Name, out eDataString enumS))
                {
                    SetValue(enumS, jp.Value.ToString());
                    //UnityEngine.Debug.Log("!!! 4 " + enumS  + ", " + name.Key + " : " + name.Value);
                    continue;
                }
            }

            Id = id;

            // struct형태로.
            var keys = GetValue(eDataString.INDICATOR_KEY);
            if (true == string.IsNullOrEmpty(keys))
                return;

            var keyList = SimulatorTableEntry.GetStringSplitToString(keys);
            if (null != keyList && 0 < keyList.Count)
            {
                foreach (var key in keyList)
                {
                    var clipData = token[key]?.ToObject<SimulatorActiveSkillClipData>();
                    if (null != clipData)
                    {
                        _indicatorClipDatas.TryAdd(key, clipData);

                        if(1 == _indicatorClipDatas.Count)
                        {
                            SetIndicatorClipData(key);
                        }
                    }
                }
            }
        }

        public void ToObject(string id, JsonElement jsonElement, JsonSerializerOptions options)
        {
            // enum들 기준으로.
            try
            {
                foreach (var obj in jsonElement.EnumerateObject())
                {
                    //UnityEngine.Debug.Log("!!! 1 : " + name.Key + " : " + name.Value);
                    if (SimulatorUtility.TryParse(obj.Name, out eDataInt enumI))
                    {
                        if (SimulatorUtility.TryParse(obj.Value.ToString(), out int value))
                        {
                            SetValue(enumI, value);
                        }
                        //UnityEngine.Debug.Log("!!! 2 " + enumI  + ", " + name.Key + " : " + name.Value);
                        continue;
                    }
                    if (SimulatorUtility.TryParse(obj.Name, out eDataFloat enumF))
                    {
                        if (SimulatorUtility.TryParse(obj.Value.ToString(), out double value))
                        {
                            var floatValue = (float)(System.Math.Truncate(value * 1000) * 0.001);
                            SetValue(enumF, floatValue);
                            //UnityEngine.Debug.Log("!!! 3 " + id + " :" + enumF + " : " + obj.Value + ", " + obj.Value.ToString() + ", " + value + ", " + floatValue);
                        }
                        continue;
                    }
                    if (SimulatorUtility.TryParse(obj.Name, out eDataString enumS))
                    {
                        SetValue(enumS, obj.Value.ToString());
                        //UnityEngine.Debug.Log("!!! 4 " + enumS  + ", " + name.Key + " : " + name.Value);
                        continue;
                    }
                }

                Id = id;

                var keys = GetValue(eDataString.INDICATOR_KEY);
                if (true == string.IsNullOrEmpty(keys))
                    return;

                var keyList = SimulatorTableEntry.GetStringSplitToString(keys);
                if (null != keyList && 0 < keyList.Count)
                {
                    foreach (var key in keyList)
                    {
                        if (false == jsonElement.TryGetProperty(key, out var clipElement))
                            continue;

                        var clipData = new SimulatorActiveSkillClipData();
                        clipData.ToObject(clipElement, options);
                        _indicatorClipDatas.TryAdd(key, clipData);

                        if (1 == _indicatorClipDatas.Count)
                        {
                            SetIndicatorClipData(key);
                        }
                    }
                }
                
            }
            catch (System.Exception ex)
            {
                SimulatorUtility.DebugLogError($"Skill - ex = {ex}");
            }
        }

        public void OnPostEntry()
        {
            // timeline data에서 indicatorTime을 얻어온다.
            var indicatorTime = GetValue(eDataFloat.INDICATOR_TIME);
            if (0.0f < indicatorTime)
            {
                return;
            }
            if (0 < _indicatorClipDatas.Count)
                return;

            var keys = GetValue(eDataString.INDICATOR_KEY);
            if (true == string.IsNullOrEmpty(keys))
                return;

            var keyList = SimulatorTableEntry.GetStringSplitToString(keys);
            if(null != keyList && 0 < keyList.Count)
            {
                foreach(var key in keyList)
                {
                    AddIndicatorClipDatas(key);
                }

                SetIndicatorClipData(keyList[0]);
            }

            /*
            var key = GetValue(eDataString.INDICATOR_KEY);
            if (0.0f < indicatorTime || string.IsNullOrEmpty(key))
            {
                return;
            }
            var index = key.IndexOf('_');
            if (0 >= index)
            {
                return;
            }
            var id = key.Remove(index, key.Length - index);
            var resourceName = key.Remove(0, index + 1);
            var playData = SimulatorTableManager.GetEntry<SimulatorTableEntryBattlePlayableData>(id);
            if (null == playData?.PlayableDataList || false == playData.PlayableDataList.ContainsKey(resourceName))
            {
                return;
            }
            var clipDatas = playData.PlayableDataList[resourceName]?.ClipDataList;
            if (null == clipDatas)
            {
                return;
            }
            for (var i = 0; i < clipDatas.Count; ++i)
            {
                if (!(clipDatas[i] is SimulatorActiveSkillClipData activeSkill))
                {
                    continue;
                }
                SetValue(eDataFloat.INDICATOR_TIME, activeSkill.INDICATOR_TIME);
                SetValue(eDataString.INDICATOR_TYPE, activeSkill.INDICATOR_TYPE);
                SetValue(eDataString.INDICATOR_FOCUS_TYPE, activeSkill.INDICATOR_FOCUS_TYPE);
                SetValue(eDataString.INDICATOR_TARGET_TYPE, activeSkill.INDICATOR_TARGET_TYPE);
                SetValue(eDataString.INDICATOR_OPTION, activeSkill.INDICATOR_OPTION);
                SetValue(eDataString.INDICATOR_PARENT, activeSkill.INDICATOR_PARENT);
                if (2 < activeSkill.INDICATOR_POS.Length)
                {
                    SetValue(eDataString.INDICATOR_POS, $"{activeSkill.INDICATOR_POS[0]},{activeSkill.INDICATOR_POS[1]},{activeSkill.INDICATOR_POS[2]}");
                }
                if (2 < activeSkill.INDICATOR_ROT.Length)
                {
                    SetValue(eDataString.INDICATOR_ROT, $"{activeSkill.INDICATOR_ROT[0]},{activeSkill.INDICATOR_ROT[1]},{activeSkill.INDICATOR_ROT[2]}");
                }
                if (2 < activeSkill.INDICATOR_SCALE.Length)
                {
                    SetValue(eDataString.INDICATOR_SCALE, $"{activeSkill.INDICATOR_SCALE[0]},{activeSkill.INDICATOR_SCALE[1]},{activeSkill.INDICATOR_SCALE[2]}");
                }
                SetValue(eDataString.INDICATOR_CONDITION_IDS, activeSkill.INDICATOR_CONDITION_IDS);
                break;
            }
            */
        }

        public bool SetIndicatorClipData(string resourceName)
        {
            if (true == string.IsNullOrEmpty(resourceName))
                return false;

            if (false == _indicatorClipDatas.ContainsKey(resourceName))
                return false;

            var activeSkill = _indicatorClipDatas[resourceName];

            // 필살기  컷신용 indicator 최소값 적용..
            // 데이터 자하드 2,3번 필살기 시작시 다른 필살기 사용가능해지는 버그 수정..
            var INDICATOR_TIME = activeSkill.INDICATOR_TIME;
            if (true == SimulatorUtility.TryParse(GetValue(eDataString.SKILL_TYPE), out eSkillType skillType))
            {
                if(eSkillType.NONE_ULTIMATE == skillType || eSkillType.ULTIMATE == skillType) // 필살기 일때..
                {
                    if(CommonValue.ULTIMATE_CUTSCENE_MIN_INDICATOR_TIME > INDICATOR_TIME) // 시간이 필살기  컷신용 indicator 최소값 보다 작으면..
                    {
                        if(true ==  SimulatorUtility.TryParse(Id, out int checkValue))
                        {
                            checkValue = (checkValue / 100) % 10;  
                            if(8 == checkValue) // 컷씬인지 체크..
                            {
                                INDICATOR_TIME = CommonValue.ULTIMATE_CUTSCENE_MIN_INDICATOR_TIME;   // 필살기  컷신용 indicator 최소값 적용.. 
                            }
                        }
                    }
                }
            }

            SetValue(eDataFloat.INDICATOR_TIME, INDICATOR_TIME);
            SetValue(eDataString.INDICATOR_TYPE, activeSkill.INDICATOR_TYPE);
            SetValue(eDataString.INDICATOR_FOCUS_TYPE, activeSkill.INDICATOR_FOCUS_TYPE);
            SetValue(eDataString.INDICATOR_TARGET_TYPE, activeSkill.INDICATOR_TARGET_TYPE);
            SetValue(eDataString.INDICATOR_OPTION, activeSkill.INDICATOR_OPTION);
            SetValue(eDataString.INDICATOR_PARENT, activeSkill.INDICATOR_PARENT);
            if (2 < activeSkill.INDICATOR_POS.Length)
            {
                SetValue(eDataString.INDICATOR_POS, $"{activeSkill.INDICATOR_POS[0]},{activeSkill.INDICATOR_POS[1]},{activeSkill.INDICATOR_POS[2]}");
            }
            if (2 < activeSkill.INDICATOR_ROT.Length)
            {
                SetValue(eDataString.INDICATOR_ROT, $"{activeSkill.INDICATOR_ROT[0]},{activeSkill.INDICATOR_ROT[1]},{activeSkill.INDICATOR_ROT[2]}");
            }
            if (2 < activeSkill.INDICATOR_SCALE.Length)
            {
                SetValue(eDataString.INDICATOR_SCALE, $"{activeSkill.INDICATOR_SCALE[0]},{activeSkill.INDICATOR_SCALE[1]},{activeSkill.INDICATOR_SCALE[2]}");
            }
            SetValue(eDataString.INDICATOR_CONDITION_IDS, activeSkill.INDICATOR_CONDITION_IDS);

            return true;
        }

        public void AddIndicatorClipDatas(string key)
        {
            if (string.IsNullOrEmpty(key))
            {
                return;
            }
            var index = key.IndexOf('_');
            if (0 >= index)
            {
                return;
            }
            var id = key.Remove(index, key.Length - index);
            var resourceName = key.Remove(0, index + 1);
            var playData = SimulatorTableManager.GetEntry<SimulatorTableEntryBattlePlayableData>(id);
            if (null == playData?.PlayableDataList || false == playData.PlayableDataList.ContainsKey(resourceName))
            {
#if UNITY_EDITOR
                if (null != playData?.PlayableDataList && false == string.IsNullOrEmpty(resourceName))
                {
                    // 인디케이터 데이터를 못찾았을때..
                    SimulatorUtility.DebugLogError($" MESSAGE = [IndicatorClip Not Found], SKILL ID = [{Id}], " +
                           $"Unit ID = [{id}], resourceName = [{resourceName}]");
                }
#endif

                return;
            }
            var clipDatas = playData.PlayableDataList[resourceName]?.ClipDataList;
            if (null == clipDatas)
            {
                return;
            }
            for (var i = 0; i < clipDatas.Count; ++i)
            {
                if (!(clipDatas[i] is SimulatorActiveSkillClipData activeSkill))
                {
                    continue;
                }

                _indicatorClipDatas.TryAdd(key, activeSkill);
                break;
            }
        }
        #endregion

        #region VALUE
        public enum ePriorityType
        {
            NONE = 0,
            NORMAL,                 // 평타
            ACTIVE1,
            ACTIVE,                 // 스킬
            ULTIMATE2,
            ULTIMATE1,
            ULTIMATE,               // 필살기
            CONNECTED,              // 연계 스킬 (Next 스킬 이나 USE_SKILL 인데 다른 스킬에 의해 중간에 끊기지 않아야하는 스킬)..
            PASSIVE_MOTION,         // 달려나가는 애들 (미카엘, 여미생, 빙결쿤)
            PASSIVE_CARD,           // 룬다 같은 엑티브 스킬
            PASSIVE_ACTION,         // 전투 시작 시 스텟이 가장 높은/낮은 적군을 찾아 행동을 한다
            PASSIVE_SUMMON,         // 전투 시작 시 소환수를 소환한다
            PASSIVE,                // 전투 시작 시 아군/적군/자신 등 버프나 디버프를 준다
            BUFFCARD,
            START,
            MAX = 99999,
        }
        public enum eDataInt
        {
            NEXT_SKILL_ID,                          // 연계된 다음 스킬.
            ENABLE_INDICATOR_SKILL,                 // 스킬사용중 다른 Indicator 스킬이 사용가능한지. 0보다 크면 사용가능. 디폴트는 불가능..
            SELECT_FAIL_DONT_REMOVE_RESERVATION,    // true : Select Skill 실패시 예약스킬 리스트를 지우지 않음..
            PLAYING_POSSIBLE_RESERVATION,           // 1 : 스킬 사용중에도 스킬 예약이 가능.. (하진성 패시브).. // https://jira.nmn.io/browse/TOGGB-4980
        }
        private readonly Dictionary<eDataInt, int> _intValues = new Dictionary<eDataInt, int>();
        public enum eDataFloat
        {
            ENABLE,                                 // 스킬 사용 가능 체크.
            ENABLE_NEXT,                            // 스킬 사용후 다음에 또 쓸 수 있나.
            ENABLE_CANCEL,                          // 스킬 사용중 다른 스킬에 의해서 cancel 될 수 있나.
            ATTACK_DISTANCE,                        // 기본 공격 거리 (0보다 작으면 제자리 공격)
            USE_EP,                                 // 스킬 사용시 필요한 에너지량.
            GET_EP,                                 // 스킬 사용후 얻는 에너지량.
            START_DELAY_TIME,
            END_DELAY_TIME,
            COOL_TIME,
            START_COOL_TIME,                        // 첫번째 coolTime 적용 보정값.
            UPDATE_COOL_TIME,                       // coolTime 계산용.
            INDICATOR_START_DELAY_TIME,             // 연출용 indicator 시작 delay 시간.
            INDICATOR_TIME,                         // 연출용 indicator 유지 시간.
            ENABLE_INDICATOR_SKILL_START_TIME,      // 다른 스킬 사용가능한 시작시간. 값이 없으면 처음부터..
            ENABLE_INDICATOR_SKILL_END_TIME,        // 다른 스킬 사용가능한 끝시간. 값이 없으면 마지막까지..
            MAX
        }
        private readonly Dictionary<eDataFloat, float> _floatValues = new Dictionary<eDataFloat, float>();
        public enum eDataString
        {
            SKILL_TYPE,             // eSkillType 참조.
            SKILL_OPTIONS,           // eSkillOption 참조.
            ACTIVATE_TYPES,         // eSkillActivateType 참조.
            RANGE_TYPE,             // eSkillRangeType 참조.
            INDICATOR_TYPE,         // eSkillIndicatorType 참조.
            INDICATOR_FOCUS_TYPE,   // eSkillIndicatorFocusType 참조.
            INDICATOR_TARGET_TYPE,  // eSkillIndicatorFocusType 참조.
            INDICATOR_OPTION,
            INDICATOR_PARENT,
            INDICATOR_POS,
            INDICATOR_ROT,
            INDICATOR_SCALE,
            INDICATOR_KEY,          // indicator 데이타 세팅을 위한 key값 (UnitID_resourceName 형태) (PLAYABLE_DATA_INFO)
            INDICATOR_CONDITION_IDS,
            CONDITION_IDS,
            SEQUENCE_IDS,
            PRIORITY,                               // 우선 순위.
        }
        private readonly Dictionary<eDataString, string> _stringValues = new Dictionary<eDataString, string>();

        private readonly Dictionary<string, SimulatorActiveSkillClipData> _indicatorClipDatas = new Dictionary<string, SimulatorActiveSkillClipData>();        

        public int GetValue(eDataInt key)
        {
            return _intValues.ContainsKey(key) ? _intValues[key] : 0;
        }

        public float GetValue(eDataFloat key)
        {
            return _floatValues.ContainsKey(key) ? _floatValues[key] : 0.0f;
        }

        public string GetValue(eDataString key)
        {
            return _stringValues.ContainsKey(key) ? _stringValues[key] : "";
        }

        public void SetValue(eDataInt key, int value)
        {
            _intValues[key] = value;
        }

        public void SetValue(eDataFloat key, float value)
        {
            _floatValues[key] = value;
        }

        public void SetValue(eDataString key, string value)
        {
            _stringValues[key] = value;
        }

        public void Copy(SimulatorTableEntryItemSkill source)
        {
            var intArray = System.Enum.GetValues(typeof(eDataInt));
            foreach (eDataInt intData in intArray)
            {
                if (source._intValues.ContainsKey(intData))
                    SetValue(intData, source.GetValue(intData));
            }
            var floatArray = System.Enum.GetValues(typeof(eDataFloat));
            foreach (eDataFloat floatData in floatArray)
            {
                if (source._floatValues.ContainsKey(floatData))
                    SetValue(floatData, source.GetValue(floatData));
            }
            var stringArray = System.Enum.GetValues(typeof(eDataString));
            foreach (eDataString stringData in stringArray)
            {
                if (source._stringValues.ContainsKey(stringData))
                    SetValue(stringData, source.GetValue(stringData));
            }

            foreach (var pair in source._indicatorClipDatas)
            {
                _indicatorClipDatas.TryAdd(pair.Key, pair.Value);
            }
        }

        public Dictionary<string, object> ToDictionary()
        {
            var tempDic =  new Dictionary<string, object>();

            foreach(var pair in _intValues)
            {
                if (0 == pair.Value)
                    continue;

                tempDic.Add(pair.Key.ToString(), pair.Value.ToString());
            }

            foreach (var pair in _floatValues)
            {
                // ENABLE_NEXT 는 기본값이 1이라서 출력..
                if (0 == pair.Value && eDataFloat.ENABLE_NEXT != pair.Key)
                    continue;

                tempDic.Add(pair.Key.ToString(), pair.Value.ToString());
            }

            foreach (var pair in _stringValues)
            {
                if(true == string.IsNullOrEmpty(pair.Value))
                    continue;

                tempDic.Add(pair.Key.ToString(), pair.Value);
            }

            foreach (var pair in _indicatorClipDatas)
            {
                if (true == string.IsNullOrEmpty(pair.Key))
                    continue;

                tempDic.Add(pair.Key, pair.Value);
            }

            /*
            var json = Newtonsoft.Json.JsonConvert.SerializeObject(tempDic, Newtonsoft.Json.Formatting.Indented);

            var jsonDic = Newtonsoft.Json.JsonConvert.DeserializeObject<Dictionary<string, string>>(json);


            var jsonObject = JObject.Parse(json);

            try
            {
                var dic = jsonObject.ToObject<Dictionary<string, string>>();
                //UnityEngine.Debug.Log(dic.Count);

            }
            catch (System.Exception e)
            {
                UnityEngine.Debug.Log(e);
            }
            */

            return tempDic;
        }

        #endregion
    }

    public class SimulatorTableItemSkill : SimulatorTableT<SimulatorTableEntryItemSkill>
    {
        #region BASE

        protected override bool UseNewtonJson => false;
        protected override string FileName => "json/simulator_item_skill.json";

        protected override SimulatorTableEntryItemSkill ToObject(string id, JToken token)
        {
            var entry = new SimulatorTableEntryItemSkill();
            if (null != token)
            {
                entry.ToObject(id, token);
            }
            return entry;
        }

#if !SERVER_MODE
        protected override SimulatorTableEntryItemSkill ToObject(string id, JsonElement jsonElement, JsonSerializerOptions options)
        {
            var entry = new SimulatorTableEntryItemSkill();
            entry.ToObject(id, jsonElement, options);
            return entry;
        }
#endif

        protected override void OnPostEntry(ref SimulatorTableEntryItemSkill entry)
        {
            base.OnPostEntry(ref entry);
            // 
            entry?.OnPostEntry();
            // timeline data에서 indicatorTime을 얻어온다.
            /*var indicatorTime = entry.GetValue(SimulatorTableEntryItemSkill.eDataFloat.INDICATOR_TIME);
            var key = entry.GetValue(SimulatorTableEntryItemSkill.eDataString.INDICATOR_KEY);
            if (0.0f < indicatorTime || string.IsNullOrEmpty(key))
            {
                return;
            }
            var index = key.IndexOf('_');
            if (0 >= index)
            {
                return;
            }
            var id = key.Remove(index, key.Length - index);
            var resourceName = key.Remove(0, index + 1);
            var playData = SimulatorTableManager.GetEntry<SimulatorTableEntryBattlePlayableData>(id);
            if (null == playData?.PlayableDataList || false == playData.PlayableDataList.ContainsKey(resourceName))
            {
                return;
            }
            var clipDatas = playData.PlayableDataList[resourceName]?.ClipDataList;
            if (null == clipDatas)
            {
                return;
            }
            for (var i = 0; i < clipDatas.Count; ++i)
            {
                if (!(clipDatas[i] is SimulatorActiveSkillClipData activeSkill))
                {
                    continue;
                }
                entry.SetValue(SimulatorTableEntryItemSkill.eDataFloat.INDICATOR_TIME, activeSkill.INDICATOR_TIME);
                entry.SetValue(SimulatorTableEntryItemSkill.eDataString.INDICATOR_TYPE, activeSkill.INDICATOR_TYPE);
                entry.SetValue(SimulatorTableEntryItemSkill.eDataString.INDICATOR_FOCUS_TYPE, activeSkill.INDICATOR_FOCUS_TYPE);
                entry.SetValue(SimulatorTableEntryItemSkill.eDataString.INDICATOR_TARGET_TYPE, activeSkill.INDICATOR_TARGET_TYPE);
                entry.SetValue(SimulatorTableEntryItemSkill.eDataString.INDICATOR_OPTION, activeSkill.INDICATOR_OPTION);
                entry.SetValue(SimulatorTableEntryItemSkill.eDataString.INDICATOR_PARENT, activeSkill.INDICATOR_PARENT);
                if (2 < activeSkill.INDICATOR_POS.Length)
                {
                    entry.SetValue(SimulatorTableEntryItemSkill.eDataString.INDICATOR_POS, $"{activeSkill.INDICATOR_POS[0]},{activeSkill.INDICATOR_POS[1]},{activeSkill.INDICATOR_POS[2]}");
                }
                if (2 < activeSkill.INDICATOR_ROT.Length)
                {
                    entry.SetValue(SimulatorTableEntryItemSkill.eDataString.INDICATOR_ROT, $"{activeSkill.INDICATOR_ROT[0]},{activeSkill.INDICATOR_ROT[1]},{activeSkill.INDICATOR_ROT[2]}");
                }
                if (2 < activeSkill.INDICATOR_SCALE.Length)
                {
                    entry.SetValue(SimulatorTableEntryItemSkill.eDataString.INDICATOR_SCALE, $"{activeSkill.INDICATOR_SCALE[0]},{activeSkill.INDICATOR_SCALE[1]},{activeSkill.INDICATOR_SCALE[2]}");
                }
                entry.SetValue(SimulatorTableEntryItemSkill.eDataString.INDICATOR_CONDITION_IDS, activeSkill.INDICATOR_CONDITION_IDS);
                break;
            }*/
        }

        #endregion
    }
}
