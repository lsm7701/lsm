using System.Collections.Generic;
using System.Text.Json;
using Newtonsoft.Json.Linq;

namespace Battle.Simulator
{
    public class SimulatorTableEntryItemSkillCondition : SimulatorTableEntry
    {
        #region VALUE

        public enum eDataInt
        {
            COUNT,
            ABSOLUTE_RETURN_VALUE,          // 타겟팅 찾기 실패의 경우 결과를 해당 값으로 고정한다. (bool)
            ABSOLUTE_FIELD_UNIT,            // 0이 아니면 inputValue가 아닌 무조건 FieldUnit으로 찾는다. (bool)
            ABSOLUTE_SELECT,                // 0이 아니면 타겟팅을 찾을때 Select()를 무조건 한다. (bool)
            UNCHECK_ENABLE_TARGET,          // 0이 아니면 DONT_TARGETING Tag를 무시하고 타겟을 찾는다. (bool)
            INT_VALUE,
            CHECK_INPUTVALUE,               // 0이 아니면 시퀀스 컨디션 탈때 도발 등에 따른 INPUTVALUE 를 초기에 넘기지 말고 마지막 결과에 체크 한다
        }
        private readonly Dictionary<eDataInt, int> _intValues = new Dictionary<eDataInt, int>();
        public enum eDataFloat
        {
            FLOAT_VALUE,
            FLOAT_OPTION,
        }
        private readonly Dictionary<eDataFloat, float> _floatValues = new Dictionary<eDataFloat, float>();
        public enum eDataString
        {
            CONDITION_TYPE,                 // eConditionType 참조.
            TARGETING_TEAM,                 // eTargetingFilterTeam 참조.
            TARGETING_SELECT,               // eTargetingFilterSelect 참조.
            TARGETING_LINKED,               // eLinkedObjectType 참조.
            OPERATOR,                       // SimulatorOperator.eType 참조.
            OPERATOR_FIX,                   // 형고정할 옵션..
            STRING_KEY,
            STRING_VALUE,
            STRING_OPTION,
            STRING_KEY_SECOND,
            STRING_VALUE_SECOND,
            STRING_OPTION_SECOND,
            STRING_OPTION_THIRD,
            TARGET_INDEX,                   // 타겟 인덱스.. 기본 -1..
        }
        private readonly Dictionary<eDataString, string> _stringValues = new Dictionary<eDataString, string>();

        public int GetValue(eDataInt key)
        {
            return _intValues.ContainsKey(key) ? _intValues[key] : 0;
        }

        public float GetValue(eDataFloat key)
        {
            return _floatValues.ContainsKey(key) ? _floatValues[key] : 0.0f;
        }

        public string GetValue(eDataString key)
        {
            return _stringValues.ContainsKey(key) ? _stringValues[key] : "";
        }

        public void SetValue(eDataInt key, int value)
        {
            _intValues[key] = value;
        }

        public void SetValue(eDataFloat key, float value)
        {
            _floatValues[key] = value;
        }

        public void SetValue(eDataString key, string value)
        {
            _stringValues[key] = value;
        }

        #endregion
    }

    public class SimulatorTableItemSkillCondition : SimulatorTableT<SimulatorTableEntryItemSkillCondition>
    {
        #region BASE

        protected override bool UseNewtonJson => false;
        protected override string FileName => "json/simulator_item_skillCondition.json";

        public string GetFileName() { return FileName; }

#if !SERVER_MODE
        public override bool Load()
        {
            if (true == BattleSimulator.TestDisableSkillLevel) 
            {
                // json 테이블을 사용..
                return base.Load();
            }
            else
            {
                // 암호화된 테이블을 사용..
                return true;
            }
        }
#endif

        protected override SimulatorTableEntryItemSkillCondition ToObject(string id, JToken token)
        {
            var entry = new SimulatorTableEntryItemSkillCondition();
            if (null != token)
            {
                var children = token.Children();
                foreach (var child in children)
                {
                    if (!(child is JProperty jp))
                    {
                        continue;
                    }
                    if (0 == string.Compare(jp.Name, "DESC", System.StringComparison.InvariantCultureIgnoreCase))
                    {
                        continue;
                    }
                    //UnityEngine.Debug.Log("!!! 1 : " + name.Key + " : " + name.Value);
                    if (SimulatorUtility.TryParse(jp.Name, out SimulatorTableEntryItemSkillCondition.eDataInt enumI))
                    {
                        //if (SimulatorUtility.TryParse(jp.Value.ToString(), out int value))
                        {
                            var value = jp.Value.Value<int>();
                            entry.SetValue(enumI, value);
                        }

                        //UnityEngine.Debug.Log("!!! 2 " + enumI  + ", " + name.Key + " : " + name.Value);
                        continue;
                    }
                    if (SimulatorUtility.TryParse(jp.Name, out SimulatorTableEntryItemSkillCondition.eDataFloat enumF))
                    {
                        //if (SimulatorUtility.TryParse(jp.Value.ToString(), out double value))
                        {
                            var value = jp.Value.Value<double>();           // !!! JToken으로 읽을때 Culture(러시아,이탈리아,프랑스...) 이슈가 있어서 이걸로 교체. 다른것도 다 바꿔야 될꺼 같지만... 일단 이것만. 관련 이슈가 있으면 그냥 테이블에서 "" 붙여서 스트링으로 읽도록.
                            var floatValue = (float) (System.Math.Truncate(value * 1000) * 0.001);
                            entry.SetValue(enumF, floatValue);
                        }

                        //UnityEngine.Debug.Log("!!! 3 " + enumF + " : " + value + ", " + floatValue);
                        continue;
                    }
                    if (SimulatorUtility.TryParse(jp.Name, out SimulatorTableEntryItemSkillCondition.eDataString enumS))
                    {
                        entry.SetValue(enumS, jp.Value.ToString());
                        //UnityEngine.Debug.Log("!!! 4 " + enumS  + ", " + name.Key + " : " + name.Value);
                        continue;
                    }
                }
            }
            entry.Id = id;
            return entry;
            //return base.toObject(id, token);
        }

#if !SERVER_MODE
        protected override SimulatorTableEntryItemSkillCondition ToObject(string id, JsonElement jsonElement, JsonSerializerOptions options)
        {
            var entry = new SimulatorTableEntryItemSkillCondition();
            foreach (var obj in jsonElement.EnumerateObject())
            {
                var k = obj.Name;
                if (0 == string.Compare(k, "DESC", System.StringComparison.InvariantCultureIgnoreCase))
                {
                    continue;
                }
                if (SimulatorUtility.TryParse(k, out SimulatorTableEntryItemSkillCondition.eDataInt enumI))
                {
                    if (SimulatorUtility.TryParse(obj.Value.ToString(), out int value))
                    {
                        entry.SetValue(enumI, value);
                    }
                    //UnityEngine.Debug.Log("!!! 2 " + enumI  + ", " + name.Key + " : " + name.Value);
                    continue;
                }
                if (SimulatorUtility.TryParse(k, out SimulatorTableEntryItemSkillCondition.eDataFloat enumF))
                {
                    if (SimulatorUtility.TryParse(obj.Value.ToString(), out double value))
                    {
                        var floatValue = (float)(System.Math.Truncate(value * 1000) * 0.001);
                        entry.SetValue(enumF, floatValue);
                    }
                    //UnityEngine.Debug.Log("!!! 3 " + enumF + " : " + value + ", " + floatValue);
                    continue;
                }
                if (SimulatorUtility.TryParse(k, out SimulatorTableEntryItemSkillCondition.eDataString enumS))
                {
                    entry.SetValue(enumS, obj.Value.ToString());
                    //UnityEngine.Debug.Log("!!! 4 " + enumS  + ", " + name.Key + " : " + name.Value);
                    continue;
                }
            }
            entry.Id = id;
            return entry;
            //return base.toObject(id, token);
        }
#endif

        #endregion
    }
}
